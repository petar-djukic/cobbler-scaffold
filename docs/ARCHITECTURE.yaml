id: architecture-cobbler-scaffold
title: Cobbler Scaffold Architecture

overview:
  summary: |
    Cobbler Scaffold is a Go library that automates AI-driven code generation through a
    two-phase loop: measure (propose tasks) and stitch (execute tasks in isolated worktrees).
    Consuming projects import the library, configure it with project-specific paths and templates,
    and expose its methods as Mage targets.

    The system operates as build tooling, not a standalone application. An Orchestrator struct
    holds a Config and provides methods that Mage calls as targets. These methods coordinate
    five subsystems: git branch management, Claude invocation (containerized via podman),
    issue tracking (beads), metrics collection, and project scaffolding.

  lifecycle: |
    Generations are the primary unit of work. A generation starts from a tagged main state,
    creates a branch, runs measure-stitch cycles, and merges the result back to main.

    States: created (branch exists, sources reset) -> running (cycles in progress) ->
    finished (tagged, ready to merge) -> merged (on main, branch deleted). An alternative
    terminal state is abandoned (generation was never merged).

    The generation branch name follows the pattern {GenPrefix}{timestamp}, where the timestamp
    is formatted as 2006-01-02-15-04-05. Tags mark lifecycle events: {branch}-start,
    {branch}-finished, {branch}-merged, {branch}-abandoned.

  coordination_pattern: |
    The cobbler workflow has two phases that run in sequence within each cycle.

    Measure reads the project state (documentation, existing issues, source code) and invokes
    Claude with a prompt template. Claude proposes tasks as a YAML list. We import these tasks
    into beads with dependency wiring.

    Stitch picks ready tasks from beads one at a time. For each task: create a git worktree
    on a task branch, invoke Claude with the task description and full project context, commit
    Claude's changes (the orchestrator manages all git operations), merge the task branch back,
    record metrics, close the task. Task branches use the pattern task/{baseBranch}-{issueID}.

    Each stitch task runs in a separate git worktree. This prevents concurrent tasks from
    interfering with each other and keeps the generation branch clean. The worktree lives in
    a temp directory ($TMPDIR/{repoName}-worktrees/{issueID}). After Claude completes, we
    merge the task branch into the generation branch and remove the worktree.

    Recovery handles interrupted runs. On resume, we scan for stale task branches, remove
    them, reset their issues to ready, and continue.

interfaces:
  - name: Orchestrator and Config
    summary: |
      The Orchestrator is the entry point. Consuming projects place a configuration.yaml at
      the repository root and call NewFromFile(), or construct a Config in Go and pass it to
      New(). Config holds all orchestrator settings. The YAML file is the sole source of
      truth for all options, making every generation reproducible.
    data_structures:
      - "Orchestrator: holds Config, provides New() and NewFromFile() constructors"
      - "Config: all orchestrator settings with YAML tags (see prd001-orchestrator-core for full field spec)"
      - "MeasurePromptData: template data for measure prompt (ProjectContext, Limit, OutputPath, UserInput, LinesMin, LinesMax, PlanningConstitution)"
      - "StitchPromptData: template data for stitch prompt (Title, ID, IssueType, Description, ExecutionConstitution, ProjectContext)"
      - "InvocationRecord: metrics per Claude invocation (Caller, StartedAt, DurationS, Tokens, LOCBefore, LOCAfter, Diff)"
      - "HistoryStats: YAML-serializable per-invocation stats saved to history directory (Caller, TaskID, TaskTitle, StartedAt, Duration, Tokens, CostUSD, LOCBefore, LOCAfter, Diff)"
      - "ClaudeResult: token usage from a Claude invocation (InputTokens, OutputTokens, CacheCreationTokens, CacheReadTokens, CostUSD, RawOutput)"
    operations:
      - "New(cfg Config) *Orchestrator: construct with explicit config"
      - "NewFromFile(path string) (*Orchestrator, error): construct from configuration.yaml"
      - "GeneratorStart(): tag main, create generation branch, reset sources (prd002)"
      - "GeneratorRun(): run measure+stitch cycles until all issues are closed (prd002)"
      - "GeneratorResume(): recover and continue interrupted run (prd002)"
      - "GeneratorStop(): merge generation into main, tag, clean up (prd002)"
      - "GeneratorReset(): destroy all generations, return to clean main (prd002)"
      - "GeneratorList(): show active and past generations (prd002)"
      - "GeneratorSwitch(): switch between generation branches (prd002)"
      - "Measure(): propose tasks via Claude (prd003)"
      - "Stitch(): execute ready tasks in worktrees (prd003)"
      - "Stats(): print LOC and documentation metrics (prd005)"
      - "Scaffold(): scaffold orchestrator into consuming project"
      - "Uninstall(): remove scaffold artifacts from target project"
      - "Tag(): create versioned doc-release tag, update version file"
      - "BuildImage(): build podman container image from embedded Dockerfile"
      - "Build(): go build the consuming project binary"
      - "Analyze(): cross-artifact consistency checking"
      - "Init(): initialize beads (prd001)"
      - "FullReset(): reset cobbler, generator, and beads (prd001)"
      - "CobblerReset(): remove scratch directory (prd003)"
      - "BeadsInit(): initialize beads database (prd001)"
      - "BeadsReset(): reset beads database (prd001)"

  - name: Prompt Templates
    summary: |
      Prompts are Go text/template strings embedded from pkg/orchestrator/prompts/measure.tmpl
      and pkg/orchestrator/prompts/stitch.tmpl. Consuming projects can override them via
      Config.MeasurePrompt and Config.StitchPrompt. Prompts are injected with phase-specific
      constitutions (planning for measure, execution for stitch) and a ProjectContext YAML blob
      containing all docs, specs, source code, and existing issues.
    data_structures:
      - "MeasurePromptData: ProjectContext (string — YAML blob of all docs, specs, source code, and issues), Limit (int), OutputPath (string), UserInput (string), LinesMin (int), LinesMax (int), PlanningConstitution (embedded YAML)"
      - "StitchPromptData: Title, ID, IssueType, Description (all strings), ExecutionConstitution (embedded YAML), ProjectContext (string — YAML blob built from worktree)"

components:
  - name: Orchestrator
    responsibility: |
      Entry point. Holds Config, provides New() and NewFromFile() constructors, manages
      logging with optional generation tagging. All other components are methods on this
      struct or package-level functions.
    capabilities:
      - Construct from Config or configuration.yaml file
      - Wire all subsystems through method dispatch
    references:
      - prd001-orchestrator-core

  - name: Generator
    responsibility: |
      Manages the generation lifecycle. Creates generation branches, runs cycles, merges
      results to main, handles resume from interrupted runs. Uses git tags to mark lifecycle
      events. Resets Go sources and re-seeds template files on start and reset.
    capabilities:
      - Start, run, resume, stop, reset, list, switch generation branches
      - Tag lifecycle events on git
      - Re-seed template files at start and reset
    references:
      - prd002-generation-lifecycle

  - name: Cobbler - Measure
    responsibility: |
      Builds the measure prompt from existing issues and project state, invokes Claude,
      parses the YAML output, and imports proposed issues into beads with dependency wiring.
      Records invocation metrics. Saves history artifacts (prompt, log, issues, stats) per
      iteration to the configured history directory.
    capabilities:
      - Build measure prompt from MeasurePromptData with full ProjectContext
      - Parse Claude YAML output into task list
      - Import tasks into beads with dependency wiring
      - Save history artifacts per iteration
    references:
      - prd003-cobbler-workflows

  - name: Cobbler - Stitch
    responsibility: |
      Picks ready tasks from beads, creates worktrees, invokes Claude, commits Claude's
      changes (the orchestrator manages all git operations — Claude is forbidden from running
      git commands), merges branches, records metrics, and closes tasks. Saves history
      artifacts (prompt, log, stats) per task. Handles recovery of stale tasks from
      interrupted runs.
    capabilities:
      - Create git worktree per task on a dedicated branch
      - Invoke Claude in worktree context with full ProjectContext
      - Commit worktree changes and merge task branch
      - Record metrics and save history artifacts per task
      - Recover stale tasks on resume
    references:
      - prd003-cobbler-workflows

  - name: Cobbler Common
    responsibility: |
      Claude invocation (runClaude), token parsing, LOC capture, invocation recording,
      history artifact saving, progress logging, configuration logging, and worktree path
      management. The progressWriter logs real-time Claude stream events (tool calls, turns,
      timing) with claude: prefix for clear log attribution.
    capabilities:
      - Wrap podman run for Claude execution with same-path mounting
      - Capture and parse token usage from Claude stream-json output
      - Snapshot LOC before and after Claude
      - Save history artifacts (prompt, log, stats YAML) to configurable directory
      - Log real-time Claude progress (turns, tool calls, timing)
    references:
      - prd003-cobbler-workflows
      - prd005-metrics-collection

  - name: Commands
    responsibility: |
      Wrapper functions for external tools. Over 50 functions wrapping git, beads (bd),
      and Go CLI commands. Centralizes binary names as constants and provides structured
      access to command output.
    capabilities:
      - Git operations (branch, worktree, tag, merge, diff)
      - Beads operations (ready, show, update, close, comments)
      - Go toolchain operations (build, vet)
    references:
      - prd001-orchestrator-core

  - name: Stats
    responsibility: |
      Collects Go LOC counts (production and test) and documentation word counts. Uses the
      configured GoSourceDirs and SpecGlobs. Output feeds invocation records and the mage
      stats target.
    capabilities:
      - Count Go LOC by production and test files
      - Count documentation words by glob pattern
    references:
      - prd005-metrics-collection

  - name: Analyze
    responsibility: |
      Cross-artifact consistency checking. Validates that PRDs, use cases, and test suites
      are properly linked and complete. Reports orphaned PRDs, missing test suites, broken
      touchpoints, and use cases not in the roadmap.
    capabilities:
      - Load and index all PRDs, use cases, test suites, and roadmap entries
      - Check PRD-to-use-case traceability via touchpoints
      - Check use-case-to-test-suite linkage
      - Identify orphaned artifacts and broken references
      - Generate detailed consistency report
    references:
      - Similar to spec-kit analyze functionality

  - name: Config
    responsibility: |
      Config struct with YAML tags, LoadConfig() for reading configuration.yaml, SeedData
      template data, Silence() and EffectiveTokenFile() helpers, and applyDefaults() for
      zero-value fields.
    capabilities:
      - Load and validate configuration.yaml
      - Apply defaults to zero-value fields
      - Resolve SeedFiles and prompt paths to content
    references:
      - prd001-orchestrator-core

  - name: Scaffold
    responsibility: |
      Scaffolds the orchestrator into consuming projects. Detects project structure (module
      path, binary name, main package, source directories), generates a configuration.yaml
      with detected values, writes a magefiles/orchestrator.go template, copies constitution
      files, and wires go.mod with the correct module dependency. Also provides Uninstall()
      to remove scaffold artifacts and PrepareTestRepo() for E2E test setup.
    capabilities:
      - Detect module path, binary name, main package, and source directories from existing project structure
      - Generate configuration.yaml with detected values and defaults
      - Write magefiles/orchestrator.go from embedded template
      - Copy design constitution to consuming project
      - Wire go.mod dependency with local replace for development or published version
      - Remove scaffold artifacts (Uninstall)
      - Download and scaffold test repos from published modules (PrepareTestRepo)
    references:
      - eng03-project-initialization

  - name: Context Assembly
    responsibility: |
      Builds a comprehensive YAML blob (ProjectContext) from the consuming project's
      documentation, specifications, source code, and existing issues. This context is
      injected into both measure and stitch prompts so Claude sees the full project state.
      Over 30 struct types model the document schema (VisionDoc, ArchitectureDoc, PRDDoc,
      UseCaseDoc, TestSuiteDoc, EngineeringDoc, ConstitutionsDoc, SourceFile, etc.).

      Phase-specific context files (measure_context.yaml and stitch_context.yaml) in the
      cobbler scratch directory override global context settings at invocation time. The
      PhaseContext struct holds include, exclude, sources, and release fields. When a phase
      context file exists, its non-empty fields replace the corresponding ProjectConfig
      values before context assembly. When absent, Config defaults apply unchanged.
    capabilities:
      - Load and marshal vision, architecture, specifications, roadmap, PRDs, use cases, test suites
      - Load engineering guidelines and constitutions
      - Load Go source files from configured directories
      - Parse existing issues from beads into structured format
      - Assemble all components into a single YAML string for prompt injection
      - Load per-phase context override files (PhaseContext) at invocation time
    references:
      - prd003-cobbler-workflows (prompt building, R9 phase context)
      - eng08-phase-context-files

  - name: Docker
    responsibility: |
      Manages the podman container image for Claude execution. Embeds a Dockerfile
      (Dockerfile.claude) via go:embed. Builds the image with versioned and latest tags.
      Auto-builds the image if it does not exist locally (ensureImage).
    capabilities:
      - Build container image from embedded Dockerfile
      - Tag images with version and latest
      - Auto-build missing images before Claude invocation
    references:
      - Design decision 4 (container-isolated Claude execution)

  - name: Logging
    responsibility: |
      Phase-aware structured logging to stderr. logf() includes timestamp, generation name
      (when set via setGeneration), and phase name with elapsed time (when set via setPhase).
      Generation tagging is set by the generator lifecycle and auto-set by measure/stitch
      when called directly. Phase tagging brackets measure and stitch workflows.
    capabilities:
      - Timestamped log lines with optional generation and phase tags
      - Phase-relative elapsed time tracking
      - Automatic generation tagging from branch name

  - name: Constitutions
    responsibility: |
      Three YAML constitutions (design, planning, execution) govern the three workflow phases.
      Design constitution is scaffolded to consuming projects. Planning and execution
      constitutions are embedded in the binary and injected into measure and stitch prompts.
      constitution_md.go provides ConstitutionToMarkdown() and ConstitutionPreviewFile()
      to render any YAML constitution to markdown for human inspection.
    capabilities:
      - Design constitution (design.yaml) defines documentation standards, format schemas, and traceability model
      - Planning constitution (planning.yaml) defines release priority, task sizing, and issue structure
      - Execution constitution (execution.yaml) defines coding standards, design patterns, and session completion
      - ConstitutionToMarkdown converts a constitution's sections slice to markdown
      - ConstitutionPreviewFile reads a constitution YAML file and prints rendered markdown to stdout
    references:
      - Design decision 8 (three-phase constitution architecture)

  - name: Pre-Cycle Analysis
    responsibility: |
      Runs cross-artifact consistency checks and code status detection before each
      measure/stitch cycle. Writes the combined result as analysis.yaml into the cobbler
      scratch directory so Claude sees the current project health in both measure and
      stitch prompts. Errors are advisory — they are logged but do not block the cycle.
    capabilities:
      - Run cross-artifact consistency checks and collect details into AnalysisDoc
      - Run code status detection (roadmap spec status vs test file presence)
      - Marshal and write AnalysisDoc to {ScratchDir}/analysis.yaml
      - Load analysis.yaml for inclusion in ProjectContext
    references:
      - prd003-cobbler-workflows

  - name: Prompt Builder
    responsibility: |
      Defines the typed document structures for measure and stitch prompts
      (MeasurePromptDoc and StitchPromptDoc) and the shared promptTemplate parser.
      Provides parseYAMLNode and substitutePlaceholders utilities used when assembling
      prompts from configuration and template files.
    capabilities:
      - Define MeasurePromptDoc and StitchPromptDoc as YAML-serializable prompt envelopes
      - Parse prompt template YAML files into promptTemplate structs
      - Validate prompt template files for schema conformance
      - Substitute {key} placeholders in template text
    references:
      - prd003-cobbler-workflows

  - name: Code Status
    responsibility: |
      Implements the CodeStatus() method (exposed as mage status). Scans the tests/
      directory for per-use-case test subdirectories, compares presence of _test.go
      files against roadmap spec status, and reports gaps where a use case is marked
      done in road-map.yaml but has no test coverage.
    capabilities:
      - Scan tests/rel*/uc* directories for _test.go files
      - Compute per-release and per-use-case implementation status
      - Detect spec-vs-code gaps and report them
      - Write CodeStatusReport into AnalysisDoc for pre-cycle context
    references:
      - prd001-orchestrator-core

  - name: Cross-Generation Comparison
    responsibility: |
      Builds binaries from two git references (or resolves paths directly) and runs
      test cases loaded from YAML spec test suites to detect behavioral differences
      between implementations. compare.go implements the top-level Compare() method
      and binary build/resolve logic; testloader.go loads CompareTestCase records
      from test suite YAML files and runs them against both binaries.
    capabilities:
      - Resolve binary paths from git tags or local paths
      - Build binaries from git tags into a temp directory
      - Load CompareTestCase records from YAML test suite files
      - Run both binaries with identical inputs and compare stdout, stderr, and exit code byte-for-byte
      - Format and report pass/fail results with diff details and summary counts
    references:
      - prd004-differential-comparison

  - name: Token Stats
    responsibility: |
      Enumerates all files that buildProjectContext would load, grouped by category,
      and reports their byte sizes. Optionally calls the Anthropic Token Counting API
      with the assembled measure prompt to produce an exact token count. Exposes the
      TokenStats() method (mage stats:tokens target).
    capabilities:
      - Enumerate standard documentation, extra context, source code, and prompt template files
      - Classify files by category (docs, source, prompts, extra)
      - Compute per-category and total byte counts
      - Estimate token counts from byte size (len/4 heuristic)
      - Call Anthropic Token Counting API for exact counts when ANTHROPIC_API_KEY is set
    references:
      - prd005-metrics-collection

  - name: VS Code Extension
    responsibility: |
      A TypeScript extension providing editor-integrated visibility into orchestrator state.
      Ten source modules implement six use cases: lifecycle commands, generation browser,
      branch comparison, issue tracker, metrics dashboard, and specification browser. The
      extension activates when configuration.yaml exists in the workspace and monitors
      .beads/, .git/refs/, and docs/specs/ for changes. Build and install are managed by
      mage vscode:push; uninstall by mage vscode:pop.
    capabilities:
      - Execute lifecycle commands (start, run, resume, stop, reset, switch) via integrated terminal (commands.ts)
      - Display generation tree with lifecycle state from git tags (generationBrowser.ts)
      - Compare version tags and generation branches with file-level diff view (comparisonBrowser.ts)
      - Parse .beads/issues.jsonl and display issues grouped by status (issuesBrowser.ts, beadsModel.ts)
      - Aggregate and display metrics dashboard as webview panel (dashboard.ts)
      - Browse specifications with touchpoint expansion and CodeLens traceability (specBrowser.ts, specModel.ts, traceability.ts)
      - Register extension entry point and wire all providers (extension.ts)
    references:
      - prd006-vscode-extension

design_decisions:
  - id: 1
    title: Library with YAML configuration
    decision: |
      We build a library that consuming projects import, configured via a configuration.yaml
      file at the repository root. Consuming projects call NewFromFile() or construct a Config
      in Go and pass it to New(). The Mage build system provides the CLI interface.
    benefits:
      - configuration.yaml records exactly what options were used, making generations reproducible
      - Consuming projects wire the library into their own magefiles
      - No duplicate flag parsing between the library and consumers
    alternatives_rejected:
      - "Standalone CLI: duplicates configuration concerns; flag values are not recorded so runs are not reproducible"

  - id: 2
    title: Git worktree isolation
    decision: |
      Each stitch task runs in a separate git worktree on its own branch. Worktrees are
      temporary and cleaned up after merge.
    benefits:
      - Concurrent tasks do not interfere with each other
      - Generation branch stays clean; failed tasks leave no partial commits
    alternatives_rejected:
      - "Running Claude on the generation branch directly: risks partial commits and merge conflicts between tasks"

  - id: 3
    title: Two-phase cobbler loop
    decision: |
      We separate task proposal (measure) from task execution (stitch), running them in
      sequence within each cycle.
    benefits:
      - Measure sees full project state before proposing work
      - Tasks can be reviewed between measure and stitch
      - Stitch executes tasks independently of each other
    alternatives_rejected:
      - "Single-phase approach: Claude both proposes and executes, losing the ability to review before execution"

  - id: 4
    title: Container-isolated Claude execution
    decision: |
      We run Claude inside a podman container. The orchestrator wraps every invocation with
      podman run, mounting the working directory at the same path inside the container. A
      pre-flight check verifies that podman is installed, the configured image is available,
      and containers can start before any workflow begins.
    benefits:
      - Isolates Claude from the host environment
      - Makes builds reproducible across machines
      - Absolute paths in prompts resolve correctly via same-path mounting
    alternatives_rejected:
      - "Running Claude as bare binary on host: simpler but provides no isolation, and environment differences are harder to debug"

  - id: 5
    title: Beads for issue tracking
    decision: |
      We use the beads git-backed issue tracker because it stores issues as JSONL files
      tracked by git. Task state travels with the generation branch and is recoverable
      from any commit.
    benefits:
      - No network access required
      - Task state is part of the git history
      - Recovery is possible from any commit
    alternatives_rejected:
      - "External issue trackers (GitHub Issues, Jira): require network access and do not travel with the branch"

  - id: 6
    title: Embedded prompt templates with override
    decision: |
      Default prompts are embedded in the binary via go:embed. Consuming projects can
      override them through Config.MeasurePrompt and Config.StitchPrompt.
    benefits:
      - Zero-configuration defaults for new consumers
      - Full customizability per project
      - No external file path management required for default behavior
    alternatives_rejected:
      - "External prompt files only: require file path management and increase deployment complexity"

  - id: 7
    title: Recovery on resume
    decision: |
      Generator resume scans for stale task branches, orphaned in-progress issues, and
      leftover worktrees. It cleans all of them up and resets affected tasks to ready
      before continuing the run.
    benefits:
      - Interrupted runs are recoverable without manual intervention
      - No dangling branches or orphaned issues after recovery
    alternatives_rejected:
      - "Requiring manual cleanup after interruption: error-prone and creates friction"

  - id: 8
    title: Three-phase constitution architecture
    decision: |
      Project governance is split into three constitutions aligned with workflow phases:
      (1) Design constitution (design.yaml) scaffolded to consuming projects for interactive
      documentation work; (2) Planning constitution (planning.yaml) embedded in the binary
      and injected into measure prompts; (3) Execution constitution (execution.yaml) embedded
      in the binary and injected into stitch prompts. Each constitution contains only the
      rules relevant to its phase.
    benefits:
      - Measure and stitch agents receive only the rules they need, reducing prompt bloat
      - Design constitution is available in consuming projects without embedding the entire orchestrator
      - Clear separation of concerns between documentation, planning, and implementation phases
      - Constitutions are YAML-structured and machine-parseable
    alternatives_rejected:
      - "Scattered markdown rule files: verbose prose, no phase separation, all rules injected into every prompt"
      - "Single monolithic constitution: measure agents see coding standards they don't need, stitch agents see format schemas they don't need"

technology_choices:
  - component: Language
    technology: Go 1.25
    purpose: Library and consuming projects use Go
  - component: Build system
    technology: Magefile (magefile/mage)
    purpose: Orchestrator methods exposed as Mage targets
  - component: Version control
    technology: git (worktrees, tags, branches)
    purpose: Isolation, lifecycle tracking, and merge
  - component: Issue tracking
    technology: Beads (bd CLI)
    purpose: Git-backed task management via JSONL
  - component: AI execution
    technology: Claude Code (CLI)
    purpose: Code generation and task execution
  - component: Container runtime
    technology: Podman
    purpose: Isolates Claude execution in containers
  - component: Prompt templating
    technology: Go text/template
    purpose: Parameterized prompts with data injection
  - component: YAML parsing
    technology: gopkg.in/yaml.v3
    purpose: Configuration file parsing

project_structure:
  - path: go.mod
    role: Module definition (gopkg.in/yaml.v3)
  - path: pkg/orchestrator/
    role: Library package; all production code
  - path: pkg/orchestrator/orchestrator.go
    role: Orchestrator struct, New(), NewFromFile(), logging
  - path: pkg/orchestrator/config.go
    role: Config struct, LoadConfig(), YAML parsing, defaults
  - path: pkg/orchestrator/cobbler.go
    role: runClaude, token parsing, LOC capture, metrics
  - path: pkg/orchestrator/measure.go
    role: Measure phase — prompt, Claude, import
  - path: pkg/orchestrator/stitch.go
    role: Stitch phase — worktree, Claude, merge
  - path: pkg/orchestrator/generator.go
    role: Generation lifecycle — start/run/resume/stop/reset
  - path: pkg/orchestrator/commands.go
    role: Git, beads, Go command wrappers
  - path: pkg/orchestrator/beads.go
    role: Beads initialization and reset
  - path: pkg/orchestrator/stats.go
    role: LOC and documentation metrics
  - path: pkg/orchestrator/analyze.go
    role: Cross-artifact consistency checking
  - path: pkg/orchestrator/scaffold.go
    role: Scaffold orchestrator into consuming projects
  - path: pkg/orchestrator/context.go
    role: ProjectContext assembly from docs, specs, source code
  - path: pkg/orchestrator/docker.go
    role: Container image build from embedded Dockerfile
  - path: pkg/orchestrator/tag.go
    role: Versioned doc-release tagging
  - path: pkg/orchestrator/version.go
    role: Version constant read/write
  - path: pkg/orchestrator/build.go
    role: Go build, lint, test, install, credential extraction
  - path: pkg/orchestrator/vscode.go
    role: VS Code extension build, package, install, uninstall
  - path: pkg/orchestrator/precycle.go
    role: Pre-cycle analysis — cross-artifact consistency check, code status, writes analysis.yaml to scratch directory before each cycle
  - path: pkg/orchestrator/constitution_md.go
    role: Constitution YAML to markdown conversion and ConstitutionPreviewFile helper
  - path: pkg/orchestrator/prompt.go
    role: Prompt document types (MeasurePromptDoc, StitchPromptDoc), template parsing, placeholder substitution
  - path: pkg/orchestrator/codestatus.go
    role: Code implementation status — scan tests/ for use-case test directories, compare roadmap spec status with test file presence, detect spec-vs-code gaps
  - path: pkg/orchestrator/testloader.go
    role: YAML test suite loader and differential binary runner for cross-generation comparison (prd004 R4-R6)
  - path: pkg/orchestrator/token_stats.go
    role: Token statistics — enumerate context files by category with byte sizes, optional Anthropic Token Counting API for exact prompt token counts
  - path: pkg/orchestrator/Dockerfile.claude
    role: Embedded Dockerfile for Claude container
  - path: pkg/orchestrator/prompts/
    role: Embedded prompt templates (measure.tmpl, stitch.tmpl)
  - path: pkg/orchestrator/constitutions/
    role: Embedded constitutions (design.yaml, planning.yaml, execution.yaml)
  - path: magefiles/
    role: Mage targets exposing orchestrator methods
  - path: vscode-extension/
    role: VS Code status dashboard (TypeScript)
  - path: docs/
    role: Documentation and specifications

implementation_status:
  current_focus: Active use — all components implemented and operational
  progress:
    - done: Generation lifecycle (start, run, resume, stop, reset, list, switch)
    - done: Measure and stitch workflows with full ProjectContext
    - done: Metrics collection and invocation records
    - done: Recovery from interrupted runs
    - done: Container-isolated Claude execution via podman
    - done: Embedded prompt templates with override
    - done: Project scaffolding for consuming repos
    - done: Context assembly from docs, specs, source code, issues
    - done: History artifact saving (prompt, log, stats per invocation)
    - done: Phase-aware structured logging
    - done: Container image build from embedded Dockerfile
    - done: Cross-artifact consistency analysis
    - done: Orchestrator-managed git commits in stitch worktrees
    - done: Phase-specific context file loading (PhaseContext override mechanism)
    - done: VS Code extension — lifecycle commands, generation browser, branch comparison, issue tracker, metrics dashboard, specification browser

related_documents:
  - doc: docs/VISION.yaml
    purpose: What we build and why; success criteria and boundaries
  - doc: docs/road-map.yaml
    purpose: Release schedule and use case status
  - doc: docs/specs/product-requirements/prd001-orchestrator-core.yaml
    purpose: Config, Orchestrator struct, YAML loading, initialization
  - doc: docs/specs/product-requirements/prd002-generation-lifecycle.yaml
    purpose: Generation start, run, resume, stop, reset, list, switch
  - doc: docs/specs/product-requirements/prd003-cobbler-workflows.yaml
    purpose: Measure and stitch phases, prompt templates, task execution
  - doc: docs/specs/product-requirements/prd005-metrics-collection.yaml
    purpose: Stats, invocation records, LOC snapshots
  - doc: docs/engineering/eng01-generation-workflow.yaml
    purpose: Generation conventions and task branch naming
  - doc: docs/engineering/eng02-prompt-templates.yaml
    purpose: Prompt template conventions and customization
  - doc: docs/engineering/eng03-project-initialization.yaml
    purpose: Prerequisites, scaffold procedure, configuration reference, Mage targets
  - doc: docs/engineering/eng04-measure-scaling.yaml
    purpose: Iterative measure strategy and scaling analysis
  - doc: docs/engineering/eng05-stitch-benchmark-analysis.md
    purpose: Stitch benchmark results and task scope recommendations
  - doc: docs/engineering/eng08-phase-context-files.yaml
    purpose: Design decisions and loading semantics for per-phase context override files
  - doc: docs/specs/product-requirements/prd006-vscode-extension.yaml
    purpose: VS Code extension requirements for lifecycle, browsing, comparison, metrics, and traceability

figures:
  - path: docs/ARCHITECTURE-diagrams.md
    caption: Figure 1 System context showing orchestrator components and external tools
